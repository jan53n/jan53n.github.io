<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Stumbling Into the Golang Spec and Trying to Make Sense of It</title>
<link rel=stylesheet href=/css/beer.min.min.e884c7e587a67c2c1ad0ab5c291a7ce678f82c0d5033dfc3854289429f9c08a5.css integrity="sha256-6ITH5YemfCwa0KtcKRp85nj4LA1QM9/DhUKJQp+cCKU=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.dd8ea56d4f86c61b0b4b61e7de4a6c8bd50fc0d411876f6abd20d8246c8c443b.css integrity="sha256-3Y6lbU+GxhsLS2Hn3kpsi9UPwNQRh29qvSDYJGyMRDs=" crossorigin=anonymous><script src=/js/main.ed351eb854edc67246b124d3e128ef04f42ffc95433cae61fd757ab9131f6f7c.js integrity="sha256-7TUeuFTtxnJGsSTT4SjvBPQv/JVDPK5h/XV6uRMfb3w=" crossorigin=anonymous></script></head><body><header class=nav-header><header class=responsive><nav class=right-align><a class=link href=/>Home</a>
<a class=link href=/blog/>Blog</a>
<a class=link href=/reads/>Reads</a>
<a class=link href=https://linkedin.com/in/jan53n>Linkedin</a></nav></header></header><main class=responsive><div class=small-line><h1>Stumbling Into the Golang Spec and Trying to Make Sense of It</h1><div class=wrap><time class=small-text datetime=2025-07-21T00:00:00+00:00>July 21, 2025</time> Â· <span class=small-text>Exploratory Technical Journaling/Rambling</span></div><p><p>I am not sure whether this is worth reading, because the Go specification is good and self-contained. Anyway, I&rsquo;m writing this. The Go language specification describes a general standard for the language itself and describes the syntax using <a href=https://en.wikipedia.org/wiki/Wirth_syntax_notation class=link>Wirth syntax notation
</a>, a variant of <a href=https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form class=link>EBNF
</a>. So I want to learn about the interface type in Go, and the first thing I want to know is how it is formed within a program, and I headed to <a href=https://go.dev/ref/spec#InterfaceType class=link>Go Programming Language Specification
</a>.</p><p>And I see:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ebnf data-lang=ebnf><span style=display:flex><span><span style=color:#66d9ef>InterfaceType  </span><span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;interface&#34;</span> <span style=color:#e6db74>&#34;{&#34;</span> { <span style=color:#66d9ef>InterfaceElem </span><span style=color:#e6db74>&#34;;&#34;</span> } <span style=color:#e6db74>&#34;}&#34;</span> .
</span></span><span style=display:flex><span><span style=color:#66d9ef>InterfaceElem  </span><span style=color:#f92672>=</span> <span style=color:#66d9ef>MethodElem </span>| <span style=color:#66d9ef>TypeElem </span>.
</span></span><span style=display:flex><span><span style=color:#66d9ef>MethodElem     </span><span style=color:#f92672>=</span> <span style=color:#66d9ef>MethodName Signature </span>.
</span></span><span style=display:flex><span><span style=color:#66d9ef>MethodName     </span><span style=color:#f92672>=</span> <span style=color:#66d9ef>identifier </span>.
</span></span><span style=display:flex><span><span style=color:#66d9ef>TypeElem       </span><span style=color:#f92672>=</span> <span style=color:#66d9ef>TypeTerm </span>{ <span style=color:#e6db74>&#34;|&#34;</span> <span style=color:#66d9ef>TypeTerm </span>} .
</span></span><span style=display:flex><span><span style=color:#66d9ef>TypeTerm       </span><span style=color:#f92672>=</span> <span style=color:#66d9ef>Type </span>| <span style=color:#66d9ef>UnderlyingType </span>.
</span></span><span style=display:flex><span><span style=color:#66d9ef>UnderlyingType </span><span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;~&#34;</span> <span style=color:#66d9ef>Type </span>.
</span></span></code></pre></div><p>And one may wonder, what are these weird things?! These, my friend, are rules that say what is an interface and what is not. Let&rsquo;s start with <code>InterfaceType</code>. This is a starting rule, and yes, each line here is a rule that is composed to finally make <code>InterfaceType</code>.</p><p>Let&rsquo;s see the first line:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ebnf data-lang=ebnf><span style=display:flex><span><span style=color:#66d9ef>InterfaceType  </span><span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;interface&#34;</span> <span style=color:#e6db74>&#34;{&#34;</span> { <span style=color:#66d9ef>InterfaceElem </span><span style=color:#e6db74>&#34;;&#34;</span> } <span style=color:#e6db74>&#34;}&#34;</span> .
</span></span></code></pre></div><p>This defines how the entire interface block is formed within a Go file, from this we can infer that every interface block starts with the <code>"interface"</code> keyword,</p><blockquote><p>this, my friend, <code>"&lt;anything>"</code> is a literal string, the exact text within <code>""</code> must appear in input.</p></blockquote><p>Followed by a <code>"{"</code>, which is also a literal string, and we can see a matching closing curly bracket literal string also exists at the end. So now, all we have left is what goes inside the <code>interface { &lt;mystery ðŸª„> }</code>. We see curly braces, not literal strings, wrapped around the rule <code>InterfaceElem</code> and <code>";"</code>.</p><blockquote><p>these curly brackets indicate repetition in this notation, specifically 0 to n times, for example <code>{ "a" }c</code> can be &ldquo;ac&rdquo; or &ldquo;c&rdquo; or &ldquo;a&rdquo; repeated n number of times followed by a &ldquo;c&rdquo;</p></blockquote><p><code>InterfaceElem</code> is another rule. Here, we can compose rules together to manage complexity. It is similar to what we&rsquo;ve seen, plus more operators, which you can reference <a href=https://go.dev/ref/spec#Notation class=link>here
</a>.</p><p>Based on this we can now write:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Read</span>([]<span style=color:#66d9ef>byte</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Write</span>([]<span style=color:#66d9ef>byte</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Close</span>() <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Ah yes, this won&rsquo;t work, because it&rsquo;s only part of the syntax, the rule itself does not give enough context for the compiler to work with, we need a type name for other things to assert interface restrictions.</p><p>Finally!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ebnf data-lang=ebnf><span style=display:flex><span><span style=color:#66d9ef>SourceFile </span><span style=color:#f92672>=</span> <span style=color:#66d9ef>PackageClause </span><span style=color:#e6db74>&#34;;&#34;</span> { <span style=color:#66d9ef>ImportDecl </span><span style=color:#e6db74>&#34;;&#34;</span> } { <span style=color:#66d9ef>TopLevelDecl </span><span style=color:#e6db74>&#34;;&#34;</span> } .
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>TopLevelDecl </span><span style=color:#f92672>=</span> <span style=color:#66d9ef>Declaration </span>| <span style=color:#66d9ef>FunctionDecl </span>| <span style=color:#66d9ef>MethodDecl </span>.
</span></span><span style=display:flex><span><span style=color:#66d9ef>Declaration  </span><span style=color:#f92672>=</span> <span style=color:#66d9ef>ConstDecl </span>| <span style=color:#66d9ef>TypeDecl </span>| <span style=color:#66d9ef>VarDecl </span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>TypeDecl </span><span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;type&#34;</span> ( <span style=color:#66d9ef>TypeSpec </span>| <span style=color:#e6db74>&#34;(&#34;</span> { <span style=color:#66d9ef>TypeSpec </span><span style=color:#e6db74>&#34;;&#34;</span> } <span style=color:#e6db74>&#34;)&#34;</span> ) .
</span></span><span style=display:flex><span><span style=color:#66d9ef>TypeSpec </span><span style=color:#f92672>=</span> <span style=color:#66d9ef>AliasDecl </span>| <span style=color:#66d9ef>TypeDef </span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>TypeDef </span><span style=color:#f92672>=</span> <span style=color:#66d9ef>identifier </span>[ <span style=color:#66d9ef>TypeParameters </span>] <span style=color:#66d9ef>Type </span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Type     </span><span style=color:#f92672>=</span> <span style=color:#66d9ef>TypeName </span>[ <span style=color:#66d9ef>TypeArgs </span>] | <span style=color:#66d9ef>TypeLit </span>| <span style=color:#e6db74>&#34;(&#34;</span> <span style=color:#66d9ef>Type </span><span style=color:#e6db74>&#34;)&#34;</span> .
</span></span><span style=display:flex><span><span style=color:#66d9ef>TypeName </span><span style=color:#f92672>=</span> <span style=color:#66d9ef>identifier </span>| <span style=color:#66d9ef>QualifiedIdent </span>.
</span></span><span style=display:flex><span><span style=color:#66d9ef>TypeArgs </span><span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;[&#34;</span> <span style=color:#66d9ef>TypeList </span>[ <span style=color:#e6db74>&#34;,&#34;</span> ] <span style=color:#e6db74>&#34;]&#34;</span> .
</span></span><span style=display:flex><span><span style=color:#66d9ef>TypeList </span><span style=color:#f92672>=</span> <span style=color:#66d9ef>Type </span>{ <span style=color:#e6db74>&#34;,&#34;</span> <span style=color:#66d9ef>Type </span>} .
</span></span><span style=display:flex><span><span style=color:#66d9ef>TypeLit  </span><span style=color:#f92672>=</span> <span style=color:#66d9ef>ArrayType </span>| <span style=color:#66d9ef>StructType </span>| <span style=color:#66d9ef>PointerType </span>| <span style=color:#66d9ef>FunctionType </span>| <span style=color:#66d9ef>InterfaceType </span>|
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>SliceType </span>| <span style=color:#66d9ef>MapType </span>| <span style=color:#66d9ef>ChannelType </span>.
</span></span></code></pre></div><p>As you can see <code>InterfaceType</code> the rule we previously explain is composed within <code>Type</code> which has the completed syntax we can work with, which the Go compiler gladly take.</p></p></div><div class=medium-space></div><div><nav class=wrap><button title=Golang class="chip fill round">Golang</button>
<button title=Exploration class="chip fill round">Exploration</button>
<button title=Golang-Sepcification class="chip fill round">Golang-Sepcification</button></nav></div></main><div class=large-space></div><div class=large-space></div><footer><footer class=responsive><nav><div class=max>Â© Copyright 2025 Jansen N. J.</div><div class=__js><button id=colpref class=no>
<span class=light-only><i>dark_mode</i>
</span><span class=dark-only><i>light_mode</i></span></button></div></nav></footer></footer></body></html>